{
  "name": "项目中的一些问题",
  "tagline": "ConcurrentModificationException",
  "body": "## 今天在项目中报出`ConcurrentModificationException`。参考[http://stackoverflow.com/questions/8189466/java-util-concurrentmodificationexception](http://stackoverflow.com/questions/8189466/java-util-concurrentmodificationexception)总结一下这个问题出现的原因以及我的解决方法。\r\n\r\n### 问题代码demo：\r\n```java\r\npublic class RemoveListElementDemo {\r\n    private static final List<Integer> integerList;\r\n    static {\r\n        integerList = new ArrayList<Integer>();\r\n        integerList.add(1);\r\n        integerList.add(2);\r\n        integerList.add(3);\r\n    }\r\n    public static void remove(Integer remove) {\r\n        for(Integer integer : integerList) {\r\n            if(integer.equals(remove)) {                \r\n                integerList.remove(integer);\r\n            }\r\n        }\r\n    }\r\n    public static void main(String args[]) { \r\n        //ok       \r\n    \tremove(2);\r\n        //java.util.ConcurrentModificationException\r\n        remove(3);   \t\r\n    }\r\n}\r\n```\r\n\r\n发现remove(2)没有问题但是下面删除3的时候报了`ConcurrentModificationException` 。\r\n\r\n### 分析：\r\n原因：\r\n* `for(Object o : Collection c)`循环遍历的时候采用的是迭代器(Iterator)进行遍历.\r\n* iterator在建立并用其来遍历collection的时候，每次调用next()方法的时会检查这个collection是否被改动（如删除和增加操作），此改动是指collection自己的remove、add等操作。如果有这样的行为，则抛出`ConcurrentModificationException`。\r\n* 当`iterator.hasNext()`为真时会调用next()方法，而hasNext()方法的内部逻辑是\r\n```java\r\npublic boolean hasNext() {\r\n     return cursor != size();\r\n}\r\n```\r\n实际情况分析：\r\n* 调用remove(2)的时候，cursor=2，删除2之后size为2，hasNext()不为真，循环停止，不会再取next故不会抛出异常。\r\n* 如果注释掉remove(2)，即进行remove(3)操作，则会抛出`ConcurrentModificationException`异常，原因是cursor为3，size为2，iterator认为它还有next，所以调用next方法，此时触发了一次检查，发现collection被改动，抛出异常。\r\n\r\n### 问题解决：\r\n如果在iterator进行迭代的时候进行collection的删操作，采用iterator.remove()方法是安全的。如果要增加元素的话，可以使用一份副本进行操作。\r\n\r\n第一次写，有错请指正！\r\n\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}